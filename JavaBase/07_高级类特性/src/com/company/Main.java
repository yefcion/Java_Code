package com.company;

/*
* 一、面向对象的特征二：继承性
* 1.为什么要设计继承性？
*
* 2.继承的格式
*   class A extends B 实现继承
*   子类：A    父类（基类SuperClass）：B
*
* 3.子类继承父类之后，父类中声明的属性、方法，子类都可以获得使用
*   明确：当父类中有私有的属性或方法是，子类同样可以获取得到，
*       知识由于封装性的设计，使得子类不可直接调用
*   子类除了通过继承，获取父类的结构之外，可以用定义自己特有的成分
*
*   extends：继承、扩展 子类是对父类功能的扩展，基本可说父类是子类的子集
*
* 4.Java 中类的继承性只支持单继承（即只能继承一个父类）
* 5.子类与父类是相对的概念
*
* 二、方法的重写  修饰符 返回值类型 方法名（参数列表）{}
* 1.前提：有子类继承父类
* 2.子类继承父类以后，父类的方法不适用于子类，则在子类中对父类方法重写、覆盖（overwrite override）
* 3.重写的规则：
*   1）要求子类方法的“返回值类型 方法名（参数列表）”与父类方法一样
*   2）子类方法的修饰符不能小于父类方法的修饰符
*   3）若父类方法抛异常，则子类方法抛的异常类型不能大于父类的
*   4）子/父类的方法必须同为 static 或同为非 static
*
*
* super：可用来修饰属性、方法、构造器
* 1）当子类与父类中有同名的属性时，可以通过“super.属性”显式地调用父类中声明地属性。
* 若想调用子类地同名属性，则用“this.属性”
* 2）当子类重写父类地方法后，在子类中若想再显式地调用父类中被重写地方法，就需要用“super.方法”
* 3）super修饰构造器：通过在子类中使用“super（形参列表）”来显式地调用父类中指定地构造器
*       在构造器内部，“super（形参列表）”必须声明在首行
*       在构造器内部，“super（形参列表）”和“this（形参列表）”只能出现一个
*       当构造器中，不显式地调用“super（形参列表）”或“this（形参列表）”中任一个，默认调用父类空参构造器
*    建议：设计一个类时，尽量提供一个空参的构造器
*
*
* 注：super访问父类中属性时，不可为private
* */
public class Main {
    public static void main(String[] args) {
        // write your code here
        Student s = new Student();
        s.eat();
        ;

        Worker w = new Worker();
        w.eat();

        Person p = new Person();
        p.eat();

        Student st = new Student();
        st.info();

        Graduate g = new Graduate();
        g.setName("hiKey");
        g.info();
    }
}
